/* LibTomCrypt, modular cryptographic library -- Tom St Denis
 *
 * LibTomCrypt is a library that provides various cryptographic
 * algorithms in a highly modular and flexible manner.
 *
 * The library is free for all purposes without any express
 * guarantee it works.
 */
#include <tomcrypt_test.h>

#if defined(LTC_MECC)

static unsigned int sizes[] = {
#ifdef LTC_ECC_SECP112R1
14,
#endif
#ifdef LTC_ECC_SECP128R1
16,
#endif
#ifdef LTC_ECC_SECP160R1
20,
#endif
#ifdef LTC_ECC_SECP192R1
24,
#endif
#ifdef LTC_ECC_SECP224R1
28,
#endif
#ifdef LTC_ECC_SECP256R1
32,
#endif
#ifdef LTC_ECC_SECP384R1
48,
#endif
#ifdef LTC_ECC_SECP512R1
66
#endif
};

#ifdef LTC_ECC_SHAMIR
static int _ecc_test_shamir(void)
{
   void *a, *modulus, *mp, *kA, *kB, *rA, *rB;
   void *mu, *ma;
   ecc_point *G, *A, *B, *C1, *C2;
   int x, y, z;
   unsigned char buf[ECC_BUF_SIZE];

   DO(mp_init_multi(&kA, &kB, &rA, &rB, &modulus, &a, &mu, &ma, NULL));
   LTC_ARGCHK((G  = ltc_ecc_new_point()) != NULL);
   LTC_ARGCHK((A  = ltc_ecc_new_point()) != NULL);
   LTC_ARGCHK((B  = ltc_ecc_new_point()) != NULL);
   LTC_ARGCHK((C1 = ltc_ecc_new_point()) != NULL);
   LTC_ARGCHK((C2 = ltc_ecc_new_point()) != NULL);

   for (x = 0; x < (int)(sizeof(sizes)/sizeof(sizes[0])); x++) {
       /* get the base point */
       for (z = 0; ltc_ecc_curves[z].prime != NULL; z++) {
           DO(mp_read_radix(modulus, ltc_ecc_curves[z].prime, 16));
           if (sizes[x] <= mp_unsigned_bin_size(modulus)) break;
       }
       LTC_ARGCHK(ltc_ecc_curves[z].prime != NULL);

       /* load it */
       DO(mp_read_radix(G->x, ltc_ecc_curves[z].Gx, 16));
       DO(mp_read_radix(G->y, ltc_ecc_curves[z].Gy, 16));
       DO(mp_set(G->z, 1));
       DO(mp_read_radix(a, ltc_ecc_curves[z].A, 16));
       DO(mp_montgomery_setup(modulus, &mp));
       DO(mp_montgomery_normalization(mu, modulus));
       DO(mp_mulmod(a, mu, modulus, ma));

       /* do 100 random tests */
       for (y = 0; y < 100; y++) {
          /* pick a random r1, r2 */
          LTC_ARGCHK(yarrow_read(buf, sizes[x], &yarrow_prng) == sizes[x]);
          DO(mp_read_unsigned_bin(rA, buf, sizes[x]));
          LTC_ARGCHK(yarrow_read(buf, sizes[x], &yarrow_prng) == sizes[x]);
          DO(mp_read_unsigned_bin(rB, buf, sizes[x]));

          /* compute rA * G = A */
          DO(ltc_mp.ecc_ptmul(rA, G, A, a, modulus, 1));

          /* compute rB * G = B */
          DO(ltc_mp.ecc_ptmul(rB, G, B, a, modulus, 1));

          /* pick a random kA, kB */
          LTC_ARGCHK(yarrow_read(buf, sizes[x], &yarrow_prng) == sizes[x]);
          DO(mp_read_unsigned_bin(kA, buf, sizes[x]));
          LTC_ARGCHK(yarrow_read(buf, sizes[x], &yarrow_prng) == sizes[x]);
          DO(mp_read_unsigned_bin(kB, buf, sizes[x]));

          /* now, compute kA*A + kB*B = C1 using the older method */
          DO(ltc_mp.ecc_ptmul(kA, A, C1, a, modulus, 0));
          DO(ltc_mp.ecc_ptmul(kB, B, C2, a, modulus, 0));
          DO(ltc_mp.ecc_ptadd(C1, C2, C1, a, modulus, mp));
          DO(ltc_mp.ecc_map(C1, modulus, mp));

          /* now compute using mul2add */
          DO(ltc_mp.ecc_mul2add(A, kA, B, kB, C2, ma, modulus));

          /* is they the sames?  */
          if ((mp_cmp(C1->x, C2->x) != LTC_MP_EQ) || (mp_cmp(C1->y, C2->y) != LTC_MP_EQ) || (mp_cmp(C1->z, C2->z) != LTC_MP_EQ)) {
             fprintf(stderr, "ECC failed shamir test: size=%d, testno=%d\n", sizes[x], y);
             return 1;
          }
      }
      mp_montgomery_free(mp);
  }
  ltc_ecc_del_point(C2);
  ltc_ecc_del_point(C1);
  ltc_ecc_del_point(B);
  ltc_ecc_del_point(A);
  ltc_ecc_del_point(G);
  mp_clear_multi(kA, kB, rA, rB, modulus, a, mu, ma, NULL);
  return 0;
}
#endif

static int _ecc_issue108(void)
{
   void      *a, *modulus, *order;
   ecc_point *Q, *Result;
   int       err;
   const ltc_ecc_curve* dp;

   /* init */
   if ((err = mp_init_multi(&modulus, &order, &a, NULL)) != CRYPT_OK) { return err; }
   Q      = ltc_ecc_new_point();
   Result = ltc_ecc_new_point();

   /* ECC-224 AKA SECP224R1 */
   if ((err = ecc_get_curve("SECP224R1", &dp)) != CRYPT_OK)               { goto done; }
   /* read A */
   if ((err = mp_read_radix(a, (char *)dp->A,  16)) != CRYPT_OK)          { goto done; }
   /* read modulus */
   if ((err = mp_read_radix(modulus, (char *)dp->prime, 16)) != CRYPT_OK) { goto done; }
   /* read order */
   if ((err = mp_read_radix(order, (char *)dp->order, 16)) != CRYPT_OK)   { goto done; }
   /* read Q */
   if ((err = mp_read_radix(Q->x, (char *)"EA3745501BBC6A70BBFDD8AEEDB18CF5073C6DC9AA7CBB5915170D60", 16)) != CRYPT_OK) { goto done; }
   if ((err = mp_read_radix(Q->y, (char *)"6C9CB8E68AABFEC989CAC5E2326E0448B7E69C3E56039BA21A44FDAC", 16)) != CRYPT_OK) { goto done; }
   mp_set(Q->z, 1);
   /* calculate nQ */
   if ((err = ltc_mp.ecc_ptmul(order, Q, Result, a, modulus, 1)) != CRYPT_OK)  { goto done; }

done:
   ltc_ecc_del_point(Result);
   ltc_ecc_del_point(Q);
   mp_clear_multi(modulus, order, a, NULL);
   return err;
}

static int _ecc_test_mp(void)
{
   void       *a, *modulus, *order;
   ecc_point  *G, *GG;
   int        i, err, primality;

   if ((err = mp_init_multi(&modulus, &order, &a, NULL)) != CRYPT_OK) {
      return err;
   }

   G   = ltc_ecc_new_point();
   GG  = ltc_ecc_new_point();
   if (G == NULL || GG == NULL) {
      mp_clear_multi(modulus, order, NULL);
      ltc_ecc_del_point(G);
      ltc_ecc_del_point(GG);
      return CRYPT_MEM;
   }

   for (i = 0; ltc_ecc_curves[i].prime != NULL; i++) {
      if ((err = mp_read_radix(a, (char *)ltc_ecc_curves[i].A,  16)) != CRYPT_OK)            { goto done; }
      if ((err = mp_read_radix(modulus, (char *)ltc_ecc_curves[i].prime, 16)) != CRYPT_OK)   { goto done; }
      if ((err = mp_read_radix(order, (char *)ltc_ecc_curves[i].order, 16)) != CRYPT_OK)     { goto done; }

      /* is prime actually prime? */
      if ((err = mp_prime_is_prime(modulus, 8, &primality)) != CRYPT_OK)                   { goto done; }
      if (primality == 0) {
         err = CRYPT_FAIL_TESTVECTOR;
         goto done;
      }

      /* is order prime ? */
      if ((err = mp_prime_is_prime(order, 8, &primality)) != CRYPT_OK)                     { goto done; }
      if (primality == 0) {
         err = CRYPT_FAIL_TESTVECTOR;
         goto done;
      }

      if ((err = mp_read_radix(G->x, (char *)ltc_ecc_curves[i].Gx, 16)) != CRYPT_OK)       { goto done; }
      if ((err = mp_read_radix(G->y, (char *)ltc_ecc_curves[i].Gy, 16)) != CRYPT_OK)       { goto done; }
      mp_set(G->z, 1);

      /* then we should have G == (order + 1)G */
      if ((err = mp_add_d(order, 1, order)) != CRYPT_OK)                                   { goto done; }
      if ((err = ltc_mp.ecc_ptmul(order, G, GG, a, modulus, 1)) != CRYPT_OK)               { goto done; }
      if (mp_cmp(G->x, GG->x) != LTC_MP_EQ || mp_cmp(G->y, GG->y) != LTC_MP_EQ) {
         err = CRYPT_FAIL_TESTVECTOR;
         goto done;
      }
   }
   err = CRYPT_OK;
done:
   ltc_ecc_del_point(GG);
   ltc_ecc_del_point(G);
   mp_clear_multi(order, modulus, a, NULL);
   return err;
}

int _ecc_old_api(void)
{
   unsigned char buf[4][4096], ch;
   unsigned long x, y, z, s;
   int           stat, stat2;
   ecc_key usera, userb, pubKey, privKey;
   int low, high;

   ecc_sizes(&low, &high);
   if (low < 14 || high < 14 || low > 100 || high > 100 || high < low) return CRYPT_FAIL_TESTVECTOR;

   for (s = 0; s < (sizeof(sizes)/sizeof(sizes[0])); s++) {
      /* make up two keys */
      DO(ecc_make_key (&yarrow_prng, find_prng ("yarrow"), sizes[s], &usera));
      DO(ecc_make_key (&yarrow_prng, find_prng ("yarrow"), sizes[s], &userb));
      if (ecc_get_size(&usera) != (int)sizes[s]) return CRYPT_FAIL_TESTVECTOR;
      if (ecc_get_size(&userb) != (int)sizes[s]) return CRYPT_FAIL_TESTVECTOR;

      /* make the shared secret */
      x = sizeof(buf[0]);
      DO(ecc_shared_secret (&usera, &userb, buf[0], &x));

      y = sizeof(buf[1]);
      DO(ecc_shared_secret (&userb, &usera, buf[1], &y));

      if (y != x) {
        fprintf(stderr, "ecc Shared keys are not same size.");
        return 1;
      }

      if (memcmp (buf[0], buf[1], x)) {
        fprintf(stderr, "ecc Shared keys not same contents.");
        return 1;
      }

      /* now export userb */
      y = sizeof(buf[0]);
      DO(ecc_export (buf[1], &y, PK_PUBLIC, &userb));
      ecc_free (&userb);

      /* import and make the shared secret again */
      DO(ecc_import (buf[1], y, &userb));

      z = sizeof(buf[0]);
      DO(ecc_shared_secret (&usera, &userb, buf[2], &z));

      if (z != x) {
        fprintf(stderr, "failed.  Size don't match?");
        return 1;
      }
      if (memcmp (buf[0], buf[2], x)) {
        fprintf(stderr, "Failed.  Contents didn't match.");
        return 1;
      }

      /* export with ANSI X9.63 */
      y = sizeof(buf[1]);
      DO(ecc_ansi_x963_export(&userb, buf[1], &y));
      ecc_free (&userb);

      /* now import the ANSI key */
      DO(ecc_ansi_x963_import(buf[1], y, &userb));

      /* shared secret */
      z = sizeof(buf[0]);
      DO(ecc_shared_secret (&usera, &userb, buf[2], &z));

      if (z != x) {
        fprintf(stderr, "failed.  Size don't match?");
        return 1;
      }
      if (memcmp (buf[0], buf[2], x)) {
        fprintf(stderr, "Failed.  Contents didn't match.");
        return 1;
      }

      ecc_free (&usera);
      ecc_free (&userb);

      /* test encrypt_key */
      DO(ecc_make_key (&yarrow_prng, find_prng ("yarrow"), sizes[s], &usera));

      /* export key */
      x = sizeof(buf[0]);
      DO(ecc_export(buf[0], &x, PK_PUBLIC, &usera));
      DO(ecc_import(buf[0], x, &pubKey));
      x = sizeof(buf[0]);
      DO(ecc_export(buf[0], &x, PK_PRIVATE, &usera));
      DO(ecc_import(buf[0], x, &privKey));

      for (ch = 0; ch < 32; ch++) {
         buf[0][ch] = ch;
      }
      y = sizeof (buf[1]);
      DO(ecc_encrypt_key (buf[0], 32, buf[1], &y, &yarrow_prng, find_prng ("yarrow"), find_hash ("sha256"), &pubKey));
      zeromem (buf[0], sizeof (buf[0]));
      x = sizeof (buf[0]);
      DO(ecc_decrypt_key (buf[1], y, buf[0], &x, &privKey));
      if (x != 32) {
        fprintf(stderr, "Failed (length)");
        return 1;
      }
      for (ch = 0; ch < 32; ch++) {
         if (buf[0][ch] != ch) {
            fprintf(stderr, "Failed (contents)");
            return 1;
         }
      }
      /* test sign_hash */
      for (ch = 0; ch < 16; ch++) {
         buf[0][ch] = ch;
      }
      x = sizeof (buf[1]);
      DO(ecc_sign_hash (buf[0], 16, buf[1], &x, &yarrow_prng, find_prng ("yarrow"), &privKey));
      DO(ecc_verify_hash (buf[1], x, buf[0], 16, &stat, &pubKey));
      buf[0][0] ^= 1;
      DO(ecc_verify_hash (buf[1], x, buf[0], 16, &stat2, &privKey));
      if (!(stat == 1 && stat2 == 0)) {
         fprintf(stderr, "ecc_verify_hash failed %d, %d, ", stat, stat2);
         return 1;
      }
      /* test sign_hash_rfc7518 */
      for (ch = 0; ch < 16; ch++) {
         buf[0][ch] = ch;
      }
      x = sizeof (buf[1]);
      DO(ecc_sign_hash_rfc7518(buf[0], 16, buf[1], &x, &yarrow_prng, find_prng ("yarrow"), &privKey));
      DO(ecc_verify_hash_rfc7518(buf[1], x, buf[0], 16, &stat, &pubKey));
      buf[0][0] ^= 1;
      DO(ecc_verify_hash_rfc7518(buf[1], x, buf[0], 16, &stat2, &privKey));
      if (!(stat == 1 && stat2 == 0)) {
         fprintf(stderr, "ecc_verify_hash_rfc7518 failed %d, %d, ", stat, stat2);
         return 1;
      }
      ecc_free (&usera);
      ecc_free (&pubKey);
      ecc_free (&privKey);
   }
   return CRYPT_OK;
}

int _ecc_new_api(void)
{
   const char* names[] = {
#ifdef LTC_ECC_SECP112R1
      "SECP112R1", "ECC-112",
      "secp112r1",              /* name is case-insensitive */
      "S E C-P-1_1_2r1",        /* should pass fuzzy matching */
#endif
#ifdef LTC_ECC_SECP112R2
      "SECP112R2",
#endif
#ifdef LTC_ECC_SECP128R1
      "SECP128R1", "ECC-128",
#endif
#ifdef LTC_ECC_SECP128R2
      "SECP128R2",
#endif
#ifdef LTC_ECC_SECP160R1
      "SECP160R1", "ECC-160",
#endif
#ifdef LTC_ECC_SECP160R2
      "SECP160R2",
#endif
#ifdef LTC_ECC_SECP160K1
      "SECP160K1",
#endif
#ifdef LTC_ECC_BRAINPOOLP160R1
      "BRAINPOOLP160R1",
#endif
#ifdef LTC_ECC_SECP192R1
      "SECP192R1", "NISTP192", "PRIME192V1", "ECC-192", "P-192",
#endif
#ifdef LTC_ECC_PRIME192V2
      "PRIME192V2",
#endif
#ifdef LTC_ECC_PRIME192V3
      "PRIME192V3",
#endif
#ifdef LTC_ECC_SECP192K1
      "SECP192K1",
#endif
#ifdef LTC_ECC_BRAINPOOLP192R1
      "BRAINPOOLP192R1",
#endif
#ifdef LTC_ECC_SECP224R1
      "SECP224R1", "NISTP224", "ECC-224", "P-224",
#endif
#ifdef LTC_ECC_SECP224K1
      "SECP224K1",
#endif
#ifdef LTC_ECC_BRAINPOOLP224R1
      "BRAINPOOLP224R1",
#endif
#ifdef LTC_ECC_PRIME239V1
      "PRIME239V1",
#endif
#ifdef LTC_ECC_PRIME239V2
      "PRIME239V2",
#endif
#ifdef LTC_ECC_PRIME239V3
      "PRIME239V3",
#endif
#ifdef LTC_ECC_SECP256R1
      "SECP256R1", "NISTP256", "PRIME256V1", "ECC-256", "P-256",
#endif
#ifdef LTC_ECC_SECP256K1
      "SECP256K1",
#endif
#ifdef LTC_ECC_BRAINPOOLP256R1
      "BRAINPOOLP256R1",
#endif
#ifdef LTC_ECC_BRAINPOOLP320R1
      "BRAINPOOLP320R1",
#endif
#ifdef LTC_ECC_SECP384R1
      "SECP384R1", "NISTP384", "ECC-384", "P-384",
#endif
#ifdef LTC_ECC_BRAINPOOLP384R1
      "BRAINPOOLP384R1",
#endif
#ifdef LTC_ECC_BRAINPOOLP512R1
      "BRAINPOOLP512R1",
#endif
#ifdef LTC_ECC_SECP521R1
      "SECP521R1", "NISTP521", "ECC-521", "P-521",
#endif
   };
   int i, j, stat;
   const ltc_ecc_curve* dp;
   ecc_key key, privkey, pubkey;
   unsigned char buf[1000];
   unsigned long len;
   unsigned char data16[16] = { 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1 };
   unsigned long len16;

   if (ltc_mp.name == NULL) return CRYPT_NOP;

   for (i = 0; i < (int)(sizeof(names)/sizeof(names[0])); i++) {
      DO(ecc_get_curve(names[i], &dp));
      /* make new key */
      DO(ecc_make_key_ex(&yarrow_prng, find_prng ("yarrow"), &key, dp));
      len = sizeof(buf);
      DO(ecc_export(buf, &len, PK_PRIVATE, &key));
      DO(ecc_import_ex(buf, len, &privkey, dp));
      ecc_free(&privkey);
      len = sizeof(buf);
      DO(ecc_export(buf, &len, PK_PUBLIC, &key));
      DO(ecc_import_ex(buf, len, &pubkey, dp));
      ecc_free(&pubkey);
      len = sizeof(buf);
      DO(ecc_ansi_x963_export(&key, buf, &len));
      ecc_free(&key);
      DO(ecc_ansi_x963_import_ex(buf, len, &pubkey, dp));
      ecc_free(&pubkey);

      /* generate new key */
      DO(ecc_set_dp(dp, &key));
      DO(ecc_generate_key(&yarrow_prng, find_prng ("yarrow"), &key));
      len = sizeof(buf);
      DO(ecc_get_key(buf, &len, PK_PRIVATE, &key));
      ecc_free(&key);

      /* load exported private key */
      DO(ecc_set_dp(dp, &privkey));
      DO(ecc_set_key(buf, len, PK_PRIVATE, &privkey));

#ifndef USE_TFM
      /* XXX-FIXME: TFM does not support sqrtmod_prime */
      /* export compressed public key */
      len = sizeof(buf);
      DO(ecc_get_key(buf, &len, PK_PUBLIC|PK_COMPRESSED, &privkey));
      if (len != 1 + (unsigned)ecc_get_size(&privkey)) return CRYPT_FAIL_TESTVECTOR;
      /* load exported public+compressed key */
      DO(ecc_set_dp(dp, &pubkey));
      DO(ecc_set_key(buf, len, PK_PUBLIC, &pubkey));
      ecc_free(&pubkey);
#endif

      /* export long public key */
      len = sizeof(buf);
      DO(ecc_get_key(buf, &len, PK_PUBLIC, &privkey));
      if (len != 1 + 2 * (unsigned)ecc_get_size(&privkey)) return CRYPT_FAIL_TESTVECTOR;
      /* load exported public key */
      DO(ecc_set_dp(dp, &pubkey));
      DO(ecc_set_key(buf, len, PK_PUBLIC, &pubkey));

      /* test signature */
      len = sizeof(buf);
      DO(ecc_sign_hash(data16, 16, buf, &len, &yarrow_prng, find_prng ("yarrow"), &privkey));
      stat = 0;
      DO(ecc_verify_hash(buf, len, data16, 16, &stat, &pubkey));
      if (stat != 1) return CRYPT_FAIL_TESTVECTOR;

      /* test encryption */
      len = sizeof(buf);
      DO(ecc_encrypt_key(data16, 16, buf, &len, &yarrow_prng, find_prng("yarrow"), find_hash("sha256"), &pubkey));
      zeromem(data16, 16);
      len16 = 16;
      DO(ecc_decrypt_key(buf, len, data16, &len16, &privkey));
      if (len16 != 16) return CRYPT_FAIL_TESTVECTOR;
      for (j = 0; j < 16; j++) if (data16[j] != 0xd1) return CRYPT_FAIL_TESTVECTOR;

      /* cleanup */
      ecc_free(&privkey);
      ecc_free(&pubkey);
   }
   return CRYPT_OK;
}

int _ecc_key_cmp(const int should_type, const ecc_key *should, const ecc_key *is)
{
   if (should_type != is->type)                               return CRYPT_ERROR;
   if (should_type == PK_PRIVATE) {
      if (mp_cmp(should->k, is->k) != LTC_MP_EQ)              return CRYPT_ERROR;
   }
   if (mp_cmp(should->dp.prime,  is->dp.prime)  != LTC_MP_EQ) return CRYPT_ERROR;
   if (mp_cmp(should->dp.A,      is->dp.A)      != LTC_MP_EQ) return CRYPT_ERROR;
   if (mp_cmp(should->dp.B,      is->dp.B)      != LTC_MP_EQ) return CRYPT_ERROR;
   if (mp_cmp(should->dp.order,  is->dp.order)  != LTC_MP_EQ) return CRYPT_ERROR;
   if (mp_cmp(should->dp.base.x, is->dp.base.x) != LTC_MP_EQ) return CRYPT_ERROR;
   if (mp_cmp(should->dp.base.y, is->dp.base.y) != LTC_MP_EQ) return CRYPT_ERROR;
   if (mp_cmp(should->pubkey.x,  is->pubkey.x)  != LTC_MP_EQ) return CRYPT_ERROR;
   if (mp_cmp(should->pubkey.y,  is->pubkey.y)  != LTC_MP_EQ) return CRYPT_ERROR;
   if (should->dp.size != is->dp.size)                        return CRYPT_ERROR;
   if (should->dp.cofactor != is->dp.cofactor)                return CRYPT_ERROR;
   return CRYPT_OK;
}

int _ecc_import_export(void) {
   const ltc_ecc_curve *cu;
   ecc_key key, pri, pub;
   unsigned char out[300];
   unsigned long outlen;

   /* the following test keys were generated by:
        # no password
        openssl ecparam -name secp256k1 -genkey -out main-key.pem
        openssl ec -in main-key.pem -param_enc explicit -out long_pri.der -outform DER
        openssl ec -in main-key.pem -param_enc explicit -conv_form compressed -out long_pric.der -outform DER
        openssl ec -in main-key.pem -param_enc explicit -pubout -out long_pub.der -outform DER
        openssl ec -in main-key.pem -param_enc explicit -pubout -conv_form compressed -out long_pubc.der -outform DER
        openssl ec -in main-key.pem -param_enc named_curve -out short_pri.der -outform DER
        openssl ec -in main-key.pem -param_enc named_curve -conv_form compressed -out short_pric.der -outform DER
        openssl ec -in main-key.pem -param_enc named_curve -pubout -out short_pub.der -outform DER
        openssl ec -in main-key.pem -param_enc named_curve -pubout -conv_form compressed -out short_pubc.der -outform DER
        # X.509 EC certificates
        openssl req -new -x509 -keyform der -key long_pri.der   -sha512 -subj '/CN=Test Cert EC' -out x509_cert_long.der   -outform der -days 365000
        openssl req -new -x509 -keyform der -key long_pric.der  -sha512 -subj '/CN=Test Cert EC' -out x509_cert_longc.der  -outform der -days 365000
        openssl req -new -x509 -keyform der -key short_pri.der  -sha512 -subj '/CN=Test Cert EC' -out x509_cert_short.der  -outform der -days 365000
        openssl req -new -x509 -keyform der -key short_pric.der -sha512 -subj '/CN=Test Cert EC' -out x509_cert_shortc.der -outform der -days 365000
    */
   static const unsigned char long_pri[] = { /* private + long public, explicit curve params */
      0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20, 0x0c, 0xf1, 0xad, 0x2f, 0x03, 0xf7, 0x91,
      0x1b, 0xba, 0x03, 0xcf, 0x23, 0x37, 0xc8, 0xf2, 0xf7, 0x36, 0xce, 0x65, 0xf1, 0x84, 0x2d, 0x7d,
      0x9f, 0x5f, 0x9e, 0x21, 0xd9, 0x5e, 0x49, 0xbd, 0x23, 0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02,
      0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f,
      0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9,
      0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d,
      0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26,
      0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6,
      0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae,
      0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01,
      0x01, 0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1,
      0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5,
      0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16, 0x91, 0xbd, 0xb2, 0xb9, 0x1b, 0x40, 0x10, 0x5a, 0xb7,
      0x6c, 0x6e, 0x32, 0x5b, 0xf7, 0x63, 0x62, 0x94, 0x24, 0x24, 0xdb, 0xec, 0x3f, 0x8b, 0xe5, 0x6e,
      0x4b, 0x64, 0x37, 0x31, 0x24, 0x79, 0x4d
   };
   static const unsigned char long_pric[] = { /* private + compressed public, explicit curve params */
      0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20, 0x0c, 0xf1, 0xad, 0x2f, 0x03, 0xf7, 0x91, 0x1b,
      0xba, 0x03, 0xcf, 0x23, 0x37, 0xc8, 0xf2, 0xf7, 0x36, 0xce, 0x65, 0xf1, 0x84, 0x2d, 0x7d, 0x9f,
      0x5f, 0x9e, 0x21, 0xd9, 0x5e, 0x49, 0xbd, 0x23, 0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01,
      0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30,
      0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc,
      0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce,
      0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc,
      0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01,
      0xa1, 0x24, 0x03, 0x22, 0x00, 0x03, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf,
      0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9,
      0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16
   };
   static const unsigned char long_pub[] = { /* long public, explicit curve params */
      0x30, 0x81, 0xf5, 0x30, 0x81, 0xae, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x30,
      0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01,
      0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff,
      0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe,
      0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b,
      0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a,
      0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17,
      0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41,
      0x41, 0x02, 0x01, 0x01, 0x03, 0x42, 0x00, 0x04, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e,
      0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e,
      0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16, 0x91, 0xbd, 0xb2, 0xb9, 0x1b, 0x40, 0x10, 0x5a,
      0xb7, 0x6c, 0x6e, 0x32, 0x5b, 0xf7, 0x63, 0x62, 0x94, 0x24, 0x24, 0xdb, 0xec, 0x3f, 0x8b, 0xe5,
      0x6e, 0x4b, 0x64, 0x37, 0x31, 0x24, 0x79, 0x4d
   };
   static const unsigned char long_pubc[] = { /* compressed public, explicit curve params */
      0x30, 0x81, 0xb5, 0x30, 0x81, 0x8e, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x30,
      0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01,
      0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff,
      0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe,
      0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b,
      0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41,
      0x41, 0x02, 0x01, 0x01, 0x03, 0x22, 0x00, 0x03, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e,
      0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e,
      0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16
   };
   static const unsigned char short_pri[] = { /* private + long public, curve by OID */
      0x30, 0x74, 0x02, 0x01, 0x01, 0x04, 0x20, 0x0c, 0xf1, 0xad, 0x2f, 0x03, 0xf7, 0x91, 0x1b, 0xba,
      0x03, 0xcf, 0x23, 0x37, 0xc8, 0xf2, 0xf7, 0x36, 0xce, 0x65, 0xf1, 0x84, 0x2d, 0x7d, 0x9f, 0x5f,
      0x9e, 0x21, 0xd9, 0x5e, 0x49, 0xbd, 0x23, 0xa0, 0x07, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x0a,
      0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf,
      0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9,
      0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16, 0x91, 0xbd, 0xb2, 0xb9, 0x1b, 0x40, 0x10, 0x5a, 0xb7, 0x6c,
      0x6e, 0x32, 0x5b, 0xf7, 0x63, 0x62, 0x94, 0x24, 0x24, 0xdb, 0xec, 0x3f, 0x8b, 0xe5, 0x6e, 0x4b,
      0x64, 0x37, 0x31, 0x24, 0x79, 0x4d
   };
   static const unsigned char short_pric[] = { /* private + compressed public, curve by OID */
      0x30, 0x54, 0x02, 0x01, 0x01, 0x04, 0x20, 0x0c, 0xf1, 0xad, 0x2f, 0x03, 0xf7, 0x91, 0x1b, 0xba,
      0x03, 0xcf, 0x23, 0x37, 0xc8, 0xf2, 0xf7, 0x36, 0xce, 0x65, 0xf1, 0x84, 0x2d, 0x7d, 0x9f, 0x5f,
      0x9e, 0x21, 0xd9, 0x5e, 0x49, 0xbd, 0x23, 0xa0, 0x07, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x0a,
      0xa1, 0x24, 0x03, 0x22, 0x00, 0x03, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf,
      0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9,
      0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16
   };
   static const unsigned char short_pub[] = { /* long public, curve by OID */
      0x30, 0x56, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b,
      0x81, 0x04, 0x00, 0x0a, 0x03, 0x42, 0x00, 0x04, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e,
      0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e,
      0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16, 0x91, 0xbd, 0xb2, 0xb9, 0x1b, 0x40, 0x10, 0x5a,
      0xb7, 0x6c, 0x6e, 0x32, 0x5b, 0xf7, 0x63, 0x62, 0x94, 0x24, 0x24, 0xdb, 0xec, 0x3f, 0x8b, 0xe5,
      0x6e, 0x4b, 0x64, 0x37, 0x31, 0x24, 0x79, 0x4d
   };
   static const unsigned char short_pubc[] = { /* compressed public, curve by OID */
      0x30, 0x36, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b,
      0x81, 0x04, 0x00, 0x0a, 0x03, 0x22, 0x00, 0x03, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e,
      0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e,
      0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16
   };
   static const unsigned char raw_pri[] = { /* raw private key */
      0x0c, 0xf1, 0xad, 0x2f, 0x03, 0xf7, 0x91, 0x1b, 0xba, 0x03, 0xcf, 0x23, 0x37, 0xc8, 0xf2, 0xf7,
      0x36, 0xce, 0x65, 0xf1, 0x84, 0x2d, 0x7d, 0x9f, 0x5f, 0x9e, 0x21, 0xd9, 0x5e, 0x49, 0xbd, 0x23
   };
   static const unsigned char raw_pub[] = { /* raw public key - long form */
      0x04, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba,
      0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5,
      0x16, 0x91, 0xbd, 0xb2, 0xb9, 0x1b, 0x40, 0x10, 0x5a, 0xb7, 0x6c, 0x6e, 0x32, 0x5b, 0xf7, 0x63,
      0x62, 0x94, 0x24, 0x24, 0xdb, 0xec, 0x3f, 0x8b, 0xe5, 0x6e, 0x4b, 0x64, 0x37, 0x31, 0x24, 0x79,
      0x4d
   };
   static const unsigned char raw_pubc[] = { /* raw public key - compressed form */
      0x03, 0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba,
      0xb6, 0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5,
      0x16
   };
   static const unsigned char x509_cert_long[] = { /* X.509 cert, long pubkey, explicit curve params */
      0x30, 0x82, 0x02, 0x13, 0x30, 0x82, 0x01, 0xba, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00,
      0xaf, 0x14, 0xe3, 0x53, 0x36, 0x06, 0x79, 0x34, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,
      0x3d, 0x04, 0x03, 0x04, 0x30, 0x17, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c,
      0x0c, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74, 0x20, 0x45, 0x43, 0x30, 0x20, 0x17,
      0x0d, 0x31, 0x37, 0x31, 0x32, 0x33, 0x30, 0x32, 0x30, 0x33, 0x33, 0x34, 0x31, 0x5a, 0x18, 0x0f,
      0x33, 0x30, 0x31, 0x37, 0x30, 0x35, 0x30, 0x32, 0x32, 0x30, 0x33, 0x33, 0x34, 0x31, 0x5a, 0x30,
      0x17, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x54, 0x65, 0x73, 0x74,
      0x20, 0x43, 0x65, 0x72, 0x74, 0x20, 0x45, 0x43, 0x30, 0x81, 0xf5, 0x30, 0x81, 0xae, 0x06, 0x07,
      0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06,
      0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00,
      0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0,
      0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2,
      0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4,
      0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47,
      0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0,
      0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0x03, 0x42, 0x00, 0x04,
      0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6,
      0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16,
      0x91, 0xbd, 0xb2, 0xb9, 0x1b, 0x40, 0x10, 0x5a, 0xb7, 0x6c, 0x6e, 0x32, 0x5b, 0xf7, 0x63, 0x62,
      0x94, 0x24, 0x24, 0xdb, 0xec, 0x3f, 0x8b, 0xe5, 0x6e, 0x4b, 0x64, 0x37, 0x31, 0x24, 0x79, 0x4d,
      0xa3, 0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x66,
      0xc9, 0x90, 0x3c, 0x8a, 0x81, 0xa3, 0x1c, 0x20, 0x61, 0xd2, 0xf3, 0xf5, 0xae, 0xa8, 0x85, 0x70,
      0xf9, 0x1f, 0x2c, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14,
      0x66, 0xc9, 0x90, 0x3c, 0x8a, 0x81, 0xa3, 0x1c, 0x20, 0x61, 0xd2, 0xf3, 0xf5, 0xae, 0xa8, 0x85,
      0x70, 0xf9, 0x1f, 0x2c, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01,
      0x01, 0xff, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x04, 0x03, 0x47,
      0x00, 0x30, 0x44, 0x02, 0x1f, 0x2a, 0x62, 0x64, 0x05, 0x67, 0xb0, 0x2c, 0xa0, 0xa3, 0xb8, 0x61,
      0x4e, 0x87, 0x06, 0x69, 0xf2, 0xda, 0x78, 0xd6, 0x0e, 0x8d, 0x9b, 0xf1, 0x43, 0x5f, 0xf6, 0x40,
      0x9d, 0x9d, 0xbd, 0xce, 0x02, 0x21, 0x00, 0xe9, 0x6f, 0x79, 0xb4, 0x4a, 0x00, 0xf7, 0xfa, 0x81,
      0x25, 0x29, 0xec, 0x79, 0xb2, 0xfa, 0x86, 0xf8, 0x84, 0xd1, 0x78, 0xe7, 0xf8, 0xfd, 0x76, 0x2d,
      0x4f, 0xfe, 0x02, 0x72, 0xba, 0x6c, 0xca
   };
   static const unsigned char x509_cert_longc[] = { /* X.509 cert, compressed pubkey, explicit curve params */
      0x30, 0x82, 0x01, 0xd3, 0x30, 0x82, 0x01, 0x7a, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00,
      0x90, 0x5b, 0x48, 0x32, 0x37, 0x4b, 0x72, 0x54, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,
      0x3d, 0x04, 0x03, 0x04, 0x30, 0x17, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c,
      0x0c, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74, 0x20, 0x45, 0x43, 0x30, 0x20, 0x17,
      0x0d, 0x31, 0x37, 0x31, 0x32, 0x33, 0x30, 0x32, 0x30, 0x33, 0x33, 0x34, 0x31, 0x5a, 0x18, 0x0f,
      0x33, 0x30, 0x31, 0x37, 0x30, 0x35, 0x30, 0x32, 0x32, 0x30, 0x33, 0x33, 0x34, 0x31, 0x5a, 0x30,
      0x17, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x54, 0x65, 0x73, 0x74,
      0x20, 0x43, 0x65, 0x72, 0x74, 0x20, 0x45, 0x43, 0x30, 0x81, 0xb5, 0x30, 0x81, 0x8e, 0x06, 0x07,
      0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06,
      0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00,
      0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0,
      0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2,
      0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0,
      0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0x03, 0x22, 0x00, 0x03,
      0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6,
      0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16,
      0xa3, 0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xca,
      0x2a, 0xa1, 0x12, 0x97, 0x96, 0x2c, 0x85, 0xd3, 0x1f, 0xb1, 0x34, 0x7c, 0x26, 0xe9, 0xd6, 0x49,
      0x9f, 0x98, 0xcf, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14,
      0xca, 0x2a, 0xa1, 0x12, 0x97, 0x96, 0x2c, 0x85, 0xd3, 0x1f, 0xb1, 0x34, 0x7c, 0x26, 0xe9, 0xd6,
      0x49, 0x9f, 0x98, 0xcf, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01,
      0x01, 0xff, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x04, 0x03, 0x47,
      0x00, 0x30, 0x44, 0x02, 0x20, 0x24, 0x7a, 0xc1, 0xb4, 0x7d, 0x1c, 0x3c, 0x23, 0xc6, 0xad, 0xea,
      0x04, 0x27, 0x27, 0x65, 0xb8, 0x72, 0x93, 0x46, 0xc9, 0xe9, 0x60, 0x8f, 0xca, 0x96, 0x30, 0x60,
      0xb3, 0x22, 0xf7, 0x3b, 0x01, 0x02, 0x20, 0x48, 0x30, 0x2a, 0x58, 0x18, 0x46, 0xdb, 0x50, 0x3e,
      0xad, 0xc3, 0xca, 0xcd, 0x6d, 0x83, 0xd4, 0xc3, 0xc4, 0xa4, 0x8f, 0x37, 0xc3, 0x1d, 0x83, 0x3c,
      0xd3, 0x1f, 0x8f, 0x38, 0x29, 0x75, 0x2c
   };
   static const unsigned char x509_cert_short[] = { /* X.509 cert, long pubkey, curve by OID */
      0x30, 0x82, 0x01, 0x74, 0x30, 0x82, 0x01, 0x1a, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00,
      0xbd, 0x81, 0x04, 0x29, 0x43, 0x12, 0x79, 0xce, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,
      0x3d, 0x04, 0x03, 0x04, 0x30, 0x17, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c,
      0x0c, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74, 0x20, 0x45, 0x43, 0x30, 0x20, 0x17,
      0x0d, 0x31, 0x37, 0x31, 0x32, 0x33, 0x30, 0x32, 0x30, 0x33, 0x33, 0x34, 0x31, 0x5a, 0x18, 0x0f,
      0x33, 0x30, 0x31, 0x37, 0x30, 0x35, 0x30, 0x32, 0x32, 0x30, 0x33, 0x33, 0x34, 0x31, 0x5a, 0x30,
      0x17, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x54, 0x65, 0x73, 0x74,
      0x20, 0x43, 0x65, 0x72, 0x74, 0x20, 0x45, 0x43, 0x30, 0x56, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86,
      0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x0a, 0x03, 0x42, 0x00, 0x04,
      0x2a, 0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6,
      0x7f, 0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16,
      0x91, 0xbd, 0xb2, 0xb9, 0x1b, 0x40, 0x10, 0x5a, 0xb7, 0x6c, 0x6e, 0x32, 0x5b, 0xf7, 0x63, 0x62,
      0x94, 0x24, 0x24, 0xdb, 0xec, 0x3f, 0x8b, 0xe5, 0x6e, 0x4b, 0x64, 0x37, 0x31, 0x24, 0x79, 0x4d,
      0xa3, 0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x66,
      0xc9, 0x90, 0x3c, 0x8a, 0x81, 0xa3, 0x1c, 0x20, 0x61, 0xd2, 0xf3, 0xf5, 0xae, 0xa8, 0x85, 0x70,
      0xf9, 0x1f, 0x2c, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14,
      0x66, 0xc9, 0x90, 0x3c, 0x8a, 0x81, 0xa3, 0x1c, 0x20, 0x61, 0xd2, 0xf3, 0xf5, 0xae, 0xa8, 0x85,
      0x70, 0xf9, 0x1f, 0x2c, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01,
      0x01, 0xff, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x04, 0x03, 0x48,
      0x00, 0x30, 0x45, 0x02, 0x21, 0x00, 0x9b, 0x4e, 0xb2, 0x6a, 0xcc, 0xfa, 0x02, 0x69, 0x22, 0x6a,
      0x32, 0x9c, 0x0c, 0xaa, 0x4c, 0xdf, 0xbb, 0x9b, 0x22, 0xfb, 0xd6, 0xec, 0x5d, 0xf9, 0x87, 0x82,
      0xeb, 0x37, 0xb8, 0x32, 0x7c, 0xd6, 0x02, 0x20, 0x50, 0x8b, 0x9f, 0xc1, 0xa8, 0x4a, 0xff, 0x49,
      0x0d, 0x7e, 0x04, 0x2d, 0x93, 0x3e, 0xdb, 0x30, 0xbc, 0x93, 0xd1, 0x16, 0x1d, 0x99, 0xbd, 0x3f,
      0xfa, 0x2a, 0x6d, 0xe0, 0x2a, 0x83, 0x55, 0x5d
   };
   static const unsigned char x509_cert_shortc[] = { /* X.509 cert, compressed pubkey, curve by OID */
      0x30, 0x82, 0x01, 0x54, 0x30, 0x81, 0xfa, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85,
      0x45, 0x77, 0x75, 0x02, 0x95, 0xf7, 0x06, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d,
      0x04, 0x03, 0x04, 0x30, 0x17, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c,
      0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74, 0x20, 0x45, 0x43, 0x30, 0x20, 0x17, 0x0d,
      0x31, 0x37, 0x31, 0x32, 0x33, 0x30, 0x32, 0x30, 0x33, 0x33, 0x34, 0x31, 0x5a, 0x18, 0x0f, 0x33,
      0x30, 0x31, 0x37, 0x30, 0x35, 0x30, 0x32, 0x32, 0x30, 0x33, 0x33, 0x34, 0x31, 0x5a, 0x30, 0x17,
      0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x20,
      0x43, 0x65, 0x72, 0x74, 0x20, 0x45, 0x43, 0x30, 0x36, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48,
      0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x0a, 0x03, 0x22, 0x00, 0x03, 0x2a,
      0xf9, 0x0b, 0xda, 0xbe, 0x71, 0x66, 0x9e, 0xd1, 0xcf, 0x12, 0xd0, 0x24, 0xaf, 0xba, 0xb6, 0x7f,
      0xfb, 0x96, 0x27, 0x3e, 0x2f, 0xbd, 0x1e, 0xd5, 0xf9, 0x8d, 0x6c, 0x73, 0x9d, 0xc5, 0x16, 0xa3,
      0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xca, 0x2a,
      0xa1, 0x12, 0x97, 0x96, 0x2c, 0x85, 0xd3, 0x1f, 0xb1, 0x34, 0x7c, 0x26, 0xe9, 0xd6, 0x49, 0x9f,
      0x98, 0xcf, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xca,
      0x2a, 0xa1, 0x12, 0x97, 0x96, 0x2c, 0x85, 0xd3, 0x1f, 0xb1, 0x34, 0x7c, 0x26, 0xe9, 0xd6, 0x49,
      0x9f, 0x98, 0xcf, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01,
      0xff, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x04, 0x03, 0x49, 0x00,
      0x30, 0x46, 0x02, 0x21, 0x00, 0xa4, 0xf9, 0x41, 0x2b, 0x4b, 0x56, 0xa5, 0xd4, 0x8c, 0xdf, 0xb0,
      0x14, 0xe3, 0xe7, 0xed, 0xcc, 0xc4, 0x46, 0x42, 0x04, 0xec, 0x15, 0x9f, 0xe1, 0xb2, 0x00, 0x07,
      0x8c, 0xc1, 0xf9, 0x25, 0xed, 0x02, 0x21, 0x00, 0x81, 0xd8, 0xc4, 0x3a, 0x9f, 0xdf, 0xc1, 0x70,
      0x9d, 0x7b, 0x70, 0x3e, 0xf5, 0x7d, 0xa4, 0xfd, 0x3c, 0xc6, 0x49, 0x93, 0xd3, 0x5b, 0xef, 0xc9,
      0xae, 0x97, 0xaf, 0x64, 0x64, 0xf9, 0x69, 0xd8
   };

   if (ltc_mp.sqrtmod_prime == NULL) return CRYPT_NOP; /* we need compressed points which requires sqrtmod_prime */

   DO(ecc_import_openssl(short_pub, sizeof(short_pub), &pub));
   DO(ecc_import_openssl(short_pri, sizeof(short_pri), &pri));
   DO(ecc_get_curve("SECP256K1", &cu));

   /* import - raw keys */
   DO(ecc_set_dp(cu, &key));
   DO(ecc_set_key(raw_pri, sizeof(raw_pri),  PK_PRIVATE, &key));
   DO(_ecc_key_cmp(PK_PRIVATE, &pri, &key));
   ecc_free(&key);
   DO(ecc_set_dp(cu, &key));
   DO(ecc_set_key(raw_pub, sizeof(raw_pub),  PK_PUBLIC,  &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);
   DO(ecc_set_dp(cu, &key));
   DO(ecc_set_key(raw_pubc, sizeof(raw_pubc), PK_PUBLIC,  &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);

   /* import - openssl compatible DER format */
   DO(ecc_import_openssl(long_pri, sizeof(long_pri),   &key));
   DO(_ecc_key_cmp(PK_PRIVATE, &pri, &key));
   ecc_free(&key);
   DO(ecc_import_openssl(long_pric, sizeof(long_pric),  &key));
   DO(_ecc_key_cmp(PK_PRIVATE, &pri, &key));
   ecc_free(&key);
   DO(ecc_import_openssl(long_pub, sizeof(long_pub),   &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);
   DO(ecc_import_openssl(long_pubc, sizeof(long_pubc),  &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);
   DO(ecc_import_openssl(short_pri, sizeof(short_pri),  &key));
   DO(_ecc_key_cmp(PK_PRIVATE, &pri, &key));
   ecc_free(&key);
   DO(ecc_import_openssl(short_pric, sizeof(short_pric), &key));
   DO(_ecc_key_cmp(PK_PRIVATE, &pri, &key));
   ecc_free(&key);
   DO(ecc_import_openssl(short_pub, sizeof(short_pub),  &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);
   DO(ecc_import_openssl(short_pubc, sizeof(short_pubc), &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);

   /* import - X.509 EC certificates */
   DO(ecc_import_x509(x509_cert_long,   sizeof(x509_cert_long),   &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);
   DO(ecc_import_x509(x509_cert_longc,  sizeof(x509_cert_longc),  &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);
   DO(ecc_import_x509(x509_cert_short,  sizeof(x509_cert_short),  &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);
   DO(ecc_import_x509(x509_cert_shortc, sizeof(x509_cert_shortc), &key));
   DO(_ecc_key_cmp(PK_PUBLIC, &pub, &key));
   ecc_free(&key);

   /* export - openssl compatible DER format */
   outlen = sizeof(out);
   DO(ecc_export_openssl(out, &outlen, PK_PRIVATE, &pri));
   if (compare_testvector(out, outlen, long_pri, sizeof(long_pri),   "e-long_pri",   0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_export_openssl(out, &outlen, PK_PRIVATE|PK_COMPRESSED, &pri));
   if (compare_testvector(out, outlen, long_pric, sizeof(long_pric),  "e-long_pric",  0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_export_openssl(out, &outlen, PK_PUBLIC, &pub));
   if (compare_testvector(out, outlen, long_pub, sizeof(long_pub),   "e-long_pub",   0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_export_openssl(out, &outlen, PK_PUBLIC|PK_COMPRESSED, &pub));
   if (compare_testvector(out, outlen, long_pubc, sizeof(long_pubc),  "e-long_pubc",  0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_export_openssl(out, &outlen, PK_PRIVATE|PK_CURVEOID, &pri));
   if (compare_testvector(out, outlen, short_pri, sizeof(short_pri),  "e-short_pri",  0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_export_openssl(out, &outlen, PK_PRIVATE|PK_CURVEOID|PK_COMPRESSED, &pri));
   if (compare_testvector(out, outlen, short_pric, sizeof(short_pric), "e-short_pric", 0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_export_openssl(out, &outlen, PK_PUBLIC|PK_CURVEOID,  &pub));
   if (compare_testvector(out, outlen, short_pub, sizeof(short_pub),  "e-short_pub",  0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_export_openssl(out, &outlen, PK_PUBLIC|PK_CURVEOID|PK_COMPRESSED, &pub));
   if (compare_testvector(out, outlen, short_pubc, sizeof(short_pubc), "e-short_pubc", 0)) return CRYPT_ERROR;

   /* export - raw keys */
   outlen = sizeof(out);
   DO(ecc_get_key(out, &outlen, PK_PRIVATE, &pri));
   if (compare_testvector(out, outlen, raw_pri, sizeof(raw_pri),    "e-raw_pri",    0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_get_key(out, &outlen, PK_PUBLIC, &pub));
   if (compare_testvector(out, outlen, raw_pub, sizeof(raw_pub),    "e-raw_pub",    0)) return CRYPT_ERROR;
   outlen = sizeof(out);
   DO(ecc_get_key(out, &outlen, PK_PUBLIC|PK_COMPRESSED, &pub));
   if (compare_testvector(out, outlen, raw_pubc, sizeof(raw_pubc),   "e-raw_pubc",   0)) return CRYPT_ERROR;

   ecc_free(&pri);
   ecc_free(&pub);
   return CRYPT_OK;
}

int ecc_tests(void)
{
   DO(_ecc_old_api()); /* up to 1.18 */
   DO(_ecc_new_api());
   DO(_ecc_import_export());
   DO(_ecc_test_mp());
   DO(_ecc_issue108());
#ifdef LTC_ECC_SHAMIR
   DO(_ecc_test_shamir());
#endif
   return CRYPT_OK;
}

#endif

/* ref:         $Format:%D$ */
/* git commit:  $Format:%H$ */
/* commit time: $Format:%ai$ */
